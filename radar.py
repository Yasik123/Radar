import re
import os
import logging
import asyncio
import random
from collections import deque
from flask import Flask
from telethon import TelegramClient, events

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# –î–∞–Ω–Ω—ã–µ Telegram
api_id = int(os.getenv("API_ID"))
api_hash = os.getenv("API_HASH")
source_channel_id = int(os.getenv("SOURCE_CHANNEL_ID"))
destination_channel_id = int(os.getenv("DESTINATION_CHANNEL_ID"))

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –∫–ª–∏–µ–Ω—Ç–∞
client = TelegramClient("session_name", api_id, api_hash)

# –û—á–µ—Ä–µ–¥—å —Å–æ–æ–±—â–µ–Ω–∏–π
message_queue = deque()

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è ID –∏—Å—Ö–æ–¥–Ω—ã—Ö –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
sent_messages_map = {}

# –ß—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤
blacklist_words = {"–¥–æ–Ω–∞—Ç", "–ø—ñ–¥—Ç—Ä–∏–º–∞—Ç–∏", "—Ä–µ–∫–ª–∞–º–∞", "–ø—ñ–¥–ø–∏—Å–∫–∞", "–ø–µ—Ä–µ–∫–∞–∑ –Ω–∞ –∫–∞—Ä—Ç—É", "–ø–æ–∂–µ—Ä—Ç–≤–∞", "–¥–æ–ø–æ–º–æ–≥–∞", "–ø—ñ–¥—Ç—Ä–∏–º–∫–∞", "–∑–±—ñ—Ä", "–∑–∞–¥–æ–Ω–∞—Ç–∏—Ç–∏"}

# –§–∏–ª—å—Ç—Ä—ã
card_pattern = re.compile(r'\b(?:\d[ -]*){12,19}\b|\bUA\d{25,}\b')
url_pattern = re.compile(r'https?://\S+', re.IGNORECASE)
city_pattern = re.compile(r'–°—Ç–µ–∂–∏—Ç–∏ –∑–∞ –æ–±—Å—Ç–∞–Ω–æ–≤–∫–æ—é .*? –º–æ–∂–Ω–∞ —Ç—É—Ç - \S+', re.IGNORECASE)
city_pattern2 = re.compile(r'–ü–æ–¥—Ä–æ–±–∏—Ü—ñ\s*-\s*t\.me/\S+\s*\(https?://t\.me/\S+?\)', re.IGNORECASE)
city_pattern3 = re.compile(r'–ü–æ–¥—Ä–æ–±–∏—Ü—ñ\s*-\s*t\.me/\S+', re.IGNORECASE)
random_letters_pattern = re.compile(r'^\s*[–∞-—è–ê-–Øa-zA-Z]{4,}\s*$', re.MULTILINE)
unwanted_text_pattern = re.compile(r'(–ü—ñ–¥—Ç—Ä–∏–º–∞—Ç–∏ –∫–∞–Ω–∞–ª, –±—É–¥—É –≤–¥—è—á–Ω–∏–π –í–∞–º:|üîó–ü–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –±–∞–Ω–∫—É)', re.IGNORECASE)
impact_pattern = re.compile(r'–ù–∞—Å–ª—ñ–¥–∫–∏.*?–¥–∏–≤–∏—Ç–∏—Å—å —Ç—É—Ç\s*-\s*t\.me/\S+(?:\s*\(https?://t\.me/\S+?\))?', re.IGNORECASE)
lonely_link_pattern = re.compile(r'^\s*[\u2800„Ö§ ]*\(https?://t\.me/\S+?\)\s*$', re.MULTILINE | re.IGNORECASE)

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
extra_text = 'üá∫üá¶ <a href="https://t.me/+9RxqorgcHYZkYTQy">–ù–µ–±–µ—Å–Ω–∏–π –í–∞—Ä—Ç–æ–≤–∏–π</a>'

# Flask API
app = Flask(__name__)

@app.route('/')
def home():
    return "–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç!"

@app.route('/health')
def health():
    return "OK", 200

# –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
def clean_message(text):
    text = re.sub(url_pattern, '', text)
    text = re.sub(impact_pattern, '', text)
    text = re.sub(lonely_link_pattern, '', text)
    text = re.sub(city_pattern3, '', text)
    text = re.sub(unwanted_text_pattern, '', text)
    text = re.sub(city_pattern, '', text)
    text = re.sub(city_pattern2, '', text)
    text = text.replace("„Ö§", "").strip()

    lines = [line.strip() for line in text.splitlines() if line.strip()]
    filtered_lines = [line for line in lines if len(line.split()) > 1]

    if filtered_lines:
        filtered_lines[0] = f"<b>{filtered_lines[0]}</b>"

    return "\n\n".join(filtered_lines)

# –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–µ–π–∫–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
async def send_fake_message():
    try:
        fake_message = "."
        sent_message = await client.send_message(destination_channel_id, fake_message)
        await asyncio.sleep(2)
        await client.delete_messages(destination_channel_id, sent_message.id)
        logger.info("üí¨ –§–µ–π–∫–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏ —É–¥–∞–ª–µ–Ω–æ.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–µ–π–∫–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}", exc_info=True)

# –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–µ–π–∫–æ–≤
async def periodic_fake_message():
    while True:
        await send_fake_message()
        await asyncio.sleep(300)  # –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
@client.on(events.NewMessage(chats=source_channel_id))
async def handler(event):
    try:
        message_text = event.message.raw_text or ""
        message_media = event.message.media

        logger.info(f"üì© –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {message_text[:60]}...")

        message_text = clean_message(message_text)

        if any(word in message_text for word in blacklist_words) or card_pattern.search(message_text):
            logger.info("üö´ –°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ.")
            return

        if message_text:
            message_text += f"\n\n{extra_text}"

        if message_media:
            sent = await client.send_file(destination_channel_id, message_media, caption=message_text, parse_mode='html')
        else:
            sent = await client.send_message(destination_channel_id, message_text, link_preview=False, parse_mode='html')

        sent_messages_map[event.message.id] = sent.id
        logger.info("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ map.")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}", exc_info=True)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
@client.on(events.MessageEdited(chats=source_channel_id))
async def edited_handler(event):
    try:
        message_id = event.message.id
        if message_id not in sent_messages_map:
            return

        message_text = event.message.raw_text or ""
        message_media = event.message.media

        if '—é–ø–¥' not in message_text.lower() and 'upd' not in message_text.lower():
            return

        message_text = clean_message(message_text)
        message_text += f"\n\n{extra_text}"

        dest_msg_id = sent_messages_map[message_id]

        if message_media:
            await client.edit_message(destination_channel_id, message=dest_msg_id, caption=message_text, parse_mode='html', link_preview=False)
        else:
            await client.edit_message(destination_channel_id, message=dest_msg_id, text=message_text, parse_mode='html', link_preview=False)

        logger.info(f"‚úèÔ∏è –°–æ–æ–±—â–µ–Ω–∏–µ {dest_msg_id} –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ—Å–ª–µ —é–ø–¥.")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏: {e}", exc_info=True)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π (–µ—Å–ª–∏ –≤–¥—Ä—É–≥ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å –µ—ë –æ—Ç–¥–µ–ª—å–Ω–æ)
async def process_message_queue():
    while True:
        if message_queue:
            message_text, message_media = message_queue.popleft()
            try:
                if message_media:
                    await client.send_file(destination_channel_id, message_media, caption=message_text, parse_mode='html')
                    logger.info("‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å –º–µ–¥–∏–∞.")
                else:
                    await client.send_message(destination_channel_id, message_text, link_preview=False, parse_mode='html')
                    logger.info("‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –±–µ–∑ –º–µ–¥–∏–∞.")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}", exc_info=True)
        else:
            await asyncio.sleep(1)
            continue

        await asyncio.sleep(random.uniform(1, 3))

# –ó–∞–ø—É—Å–∫ Flask
async def run_flask():
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, lambda: app.run(host="0.0.0.0", port=int(os.getenv("PORT", 10000)), debug=False, use_reloader=False))

# –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
async def main():
    await client.start()
    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ Telegram")

    asyncio.create_task(run_flask())
    asyncio.create_task(periodic_fake_message())
    asyncio.create_task(process_message_queue())

    await client.run_until_disconnected()

if __name__ == "__main__":
    asyncio.run(main())
